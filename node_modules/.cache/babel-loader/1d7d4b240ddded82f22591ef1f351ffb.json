{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.shallowCompare = exports.validateRedirect = exports.insertParams = exports.resolve = exports.match = exports.pick = exports.startsWith = undefined;\n\nvar _invariant = require(\"invariant\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\n\n\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n}; ////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\n\n\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? (0, _invariant2.default)(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : (0, _invariant2.default)(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n}; ////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\n\n\nvar match = function match(path, uri) {\n  return pick([{\n    path: path\n  }], uri);\n}; ////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\n\n\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname); // ?a=b, /users?b=c => /users?a=b\n\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  } // profile, /users/789 => /users/789/profile\n\n\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  } // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n\n\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n}; ////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n      pathBase = _path$split[0],\n      _path$split$ = _path$split[1],\n      query = _path$split$ === undefined ? \"\" : _path$split$;\n\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n      search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n}; ////////////////////////////////////////////////////////////////////////////////\n// Junk\n\n\nvar paramRe = /^:(.+)/;\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\n\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\n\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return {\n    route: route,\n    score: score,\n    index: index\n  };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\n\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n}; ////////////////////////////////////////////////////////////////////////////////\n\n\nexports.startsWith = startsWith;\nexports.pick = pick;\nexports.match = match;\nexports.resolve = resolve;\nexports.insertParams = insertParams;\nexports.validateRedirect = validateRedirect;\nexports.shallowCompare = shallowCompare;","map":{"version":3,"names":["exports","__esModule","shallowCompare","validateRedirect","insertParams","resolve","match","pick","startsWith","undefined","_invariant","require","_invariant2","_interopRequireDefault","obj","default","string","search","substr","length","routes","uri","default_","_uri$split","split","uriPathname","uriSegments","segmentize","isRootUri","ranked","rankRoutes","i","l","missed","route","params","routeSegments","path","max","Math","index","routeSegment","uriSegment","isSplat","param","slice","map","decodeURIComponent","join","dynamicMatch","paramRe","exec","matchIsNotReserved","reservedNames","indexOf","process","env","NODE_ENV","value","to","base","_to$split","toPathname","toQuery","_base$split","basePathname","toSegments","baseSegments","addQuery","pathname","concat","allSegments","segments","segment","pop","push","_path$split","pathBase","_path$split$","query","constructedPath","_params$location","location","_params$location$sear","searchSplit","from","filter","isDynamic","fromString","sort","toString","SEGMENT_POINTS","STATIC_POINTS","DYNAMIC_POINTS","SPLAT_PENALTY","ROOT_POINTS","isRootSegment","test","rankRoute","score","reduce","a","b","replace","_len","arguments","Array","_key","q","obj1","obj2","obj1Keys","Object","keys","every","key","hasOwnProperty"],"sources":["/Users/lazarbogdan/test/medicacasa-frontend/node_modules/@reach/router/lib/utils.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.shallowCompare = exports.validateRedirect = exports.insertParams = exports.resolve = exports.match = exports.pick = exports.startsWith = undefined;\n\nvar _invariant = require(\"invariant\");\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n////////////////////////////////////////////////////////////////////////////////\n// startsWith(string, search) - Check if `string` starts with `search`\nvar startsWith = function startsWith(string, search) {\n  return string.substr(0, search.length) === search;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// pick(routes, uri)\n//\n// Ranks and picks the best route to match. Each segment gets the highest\n// amount of points, then the type of segment gets an additional amount of\n// points where\n//\n//     static > dynamic > splat > root\n//\n// This way we don't have to worry about the order of our routes, let the\n// computers do it.\n//\n// A route looks like this\n//\n//     { path, default, value }\n//\n// And a returned match looks like:\n//\n//     { route, params, uri }\n//\n// I know, I should use TypeScript not comments for these types.\nvar pick = function pick(routes, uri) {\n  var match = void 0;\n  var default_ = void 0;\n\n  var _uri$split = uri.split(\"?\"),\n      uriPathname = _uri$split[0];\n\n  var uriSegments = segmentize(uriPathname);\n  var isRootUri = uriSegments[0] === \"\";\n  var ranked = rankRoutes(routes);\n\n  for (var i = 0, l = ranked.length; i < l; i++) {\n    var missed = false;\n    var route = ranked[i].route;\n\n    if (route.default) {\n      default_ = {\n        route: route,\n        params: {},\n        uri: uri\n      };\n      continue;\n    }\n\n    var routeSegments = segmentize(route.path);\n    var params = {};\n    var max = Math.max(uriSegments.length, routeSegments.length);\n    var index = 0;\n\n    for (; index < max; index++) {\n      var routeSegment = routeSegments[index];\n      var uriSegment = uriSegments[index];\n\n      if (isSplat(routeSegment)) {\n        // Hit a splat, just grab the rest, and return a match\n        // uri:   /files/documents/work\n        // route: /files/*\n        var param = routeSegment.slice(1) || \"*\";\n        params[param] = uriSegments.slice(index).map(decodeURIComponent).join(\"/\");\n        break;\n      }\n\n      if (uriSegment === undefined) {\n        // URI is shorter than the route, no match\n        // uri:   /users\n        // route: /users/:userId\n        missed = true;\n        break;\n      }\n\n      var dynamicMatch = paramRe.exec(routeSegment);\n\n      if (dynamicMatch && !isRootUri) {\n        var matchIsNotReserved = reservedNames.indexOf(dynamicMatch[1]) === -1;\n        !matchIsNotReserved ? process.env.NODE_ENV !== \"production\" ? (0, _invariant2.default)(false, \"<Router> dynamic segment \\\"\" + dynamicMatch[1] + \"\\\" is a reserved name. Please use a different name in path \\\"\" + route.path + \"\\\".\") : (0, _invariant2.default)(false) : void 0;\n        var value = decodeURIComponent(uriSegment);\n        params[dynamicMatch[1]] = value;\n      } else if (routeSegment !== uriSegment) {\n        // Current segments don't match, not dynamic, not splat, so no match\n        // uri:   /users/123/settings\n        // route: /users/:id/profile\n        missed = true;\n        break;\n      }\n    }\n\n    if (!missed) {\n      match = {\n        route: route,\n        params: params,\n        uri: \"/\" + uriSegments.slice(0, index).join(\"/\")\n      };\n      break;\n    }\n  }\n\n  return match || default_ || null;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// match(path, uri) - Matches just one path to a uri, also lol\nvar match = function match(path, uri) {\n  return pick([{ path: path }], uri);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// resolve(to, basepath)\n//\n// Resolves URIs as though every path is a directory, no files.  Relative URIs\n// in the browser can feel awkward because not only can you be \"in a directory\"\n// you can be \"at a file\", too. For example\n//\n//     browserSpecResolve('foo', '/bar/') => /bar/foo\n//     browserSpecResolve('foo', '/bar') => /foo\n//\n// But on the command line of a file system, it's not as complicated, you can't\n// `cd` from a file, only directories.  This way, links have to know less about\n// their current path. To go deeper you can do this:\n//\n//     <Link to=\"deeper\"/>\n//     // instead of\n//     <Link to=`{${props.uri}/deeper}`/>\n//\n// Just like `cd`, if you want to go deeper from the command line, you do this:\n//\n//     cd deeper\n//     # not\n//     cd $(pwd)/deeper\n//\n// By treating every path as a directory, linking to relative paths should\n// require less contextual information and (fingers crossed) be more intuitive.\nvar resolve = function resolve(to, base) {\n  // /foo/bar, /baz/qux => /foo/bar\n  if (startsWith(to, \"/\")) {\n    return to;\n  }\n\n  var _to$split = to.split(\"?\"),\n      toPathname = _to$split[0],\n      toQuery = _to$split[1];\n\n  var _base$split = base.split(\"?\"),\n      basePathname = _base$split[0];\n\n  var toSegments = segmentize(toPathname);\n  var baseSegments = segmentize(basePathname);\n\n  // ?a=b, /users?b=c => /users?a=b\n  if (toSegments[0] === \"\") {\n    return addQuery(basePathname, toQuery);\n  }\n\n  // profile, /users/789 => /users/789/profile\n  if (!startsWith(toSegments[0], \".\")) {\n    var pathname = baseSegments.concat(toSegments).join(\"/\");\n    return addQuery((basePathname === \"/\" ? \"\" : \"/\") + pathname, toQuery);\n  }\n\n  // ./         /users/123  =>  /users/123\n  // ../        /users/123  =>  /users\n  // ../..      /users/123  =>  /\n  // ../../one  /a/b/c/d    =>  /a/b/one\n  // .././one   /a/b/c/d    =>  /a/b/c/one\n  var allSegments = baseSegments.concat(toSegments);\n  var segments = [];\n  for (var i = 0, l = allSegments.length; i < l; i++) {\n    var segment = allSegments[i];\n    if (segment === \"..\") segments.pop();else if (segment !== \".\") segments.push(segment);\n  }\n\n  return addQuery(\"/\" + segments.join(\"/\"), toQuery);\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// insertParams(path, params)\n\nvar insertParams = function insertParams(path, params) {\n  var _path$split = path.split(\"?\"),\n      pathBase = _path$split[0],\n      _path$split$ = _path$split[1],\n      query = _path$split$ === undefined ? \"\" : _path$split$;\n\n  var segments = segmentize(pathBase);\n  var constructedPath = \"/\" + segments.map(function (segment) {\n    var match = paramRe.exec(segment);\n    return match ? params[match[1]] : segment;\n  }).join(\"/\");\n  var _params$location = params.location;\n  _params$location = _params$location === undefined ? {} : _params$location;\n  var _params$location$sear = _params$location.search,\n      search = _params$location$sear === undefined ? \"\" : _params$location$sear;\n\n  var searchSplit = search.split(\"?\")[1] || \"\";\n  constructedPath = addQuery(constructedPath, query, searchSplit);\n  return constructedPath;\n};\n\nvar validateRedirect = function validateRedirect(from, to) {\n  var filter = function filter(segment) {\n    return isDynamic(segment);\n  };\n  var fromString = segmentize(from).filter(filter).sort().join(\"/\");\n  var toString = segmentize(to).filter(filter).sort().join(\"/\");\n  return fromString === toString;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Junk\nvar paramRe = /^:(.+)/;\n\nvar SEGMENT_POINTS = 4;\nvar STATIC_POINTS = 3;\nvar DYNAMIC_POINTS = 2;\nvar SPLAT_PENALTY = 1;\nvar ROOT_POINTS = 1;\n\nvar isRootSegment = function isRootSegment(segment) {\n  return segment === \"\";\n};\nvar isDynamic = function isDynamic(segment) {\n  return paramRe.test(segment);\n};\nvar isSplat = function isSplat(segment) {\n  return segment && segment[0] === \"*\";\n};\n\nvar rankRoute = function rankRoute(route, index) {\n  var score = route.default ? 0 : segmentize(route.path).reduce(function (score, segment) {\n    score += SEGMENT_POINTS;\n    if (isRootSegment(segment)) score += ROOT_POINTS;else if (isDynamic(segment)) score += DYNAMIC_POINTS;else if (isSplat(segment)) score -= SEGMENT_POINTS + SPLAT_PENALTY;else score += STATIC_POINTS;\n    return score;\n  }, 0);\n  return { route: route, score: score, index: index };\n};\n\nvar rankRoutes = function rankRoutes(routes) {\n  return routes.map(rankRoute).sort(function (a, b) {\n    return a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index;\n  });\n};\n\nvar segmentize = function segmentize(uri) {\n  return uri\n  // strip starting/ending slashes\n  .replace(/(^\\/+|\\/+$)/g, \"\").split(\"/\");\n};\n\nvar addQuery = function addQuery(pathname) {\n  for (var _len = arguments.length, query = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    query[_key - 1] = arguments[_key];\n  }\n\n  query = query.filter(function (q) {\n    return q && q.length > 0;\n  });\n  return pathname + (query && query.length > 0 ? \"?\" + query.join(\"&\") : \"\");\n};\n\nvar reservedNames = [\"uri\", \"path\"];\n\n/**\n * Shallow compares two objects.\n * @param {Object} obj1 The first object to compare.\n * @param {Object} obj2 The second object to compare.\n */\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  var obj1Keys = Object.keys(obj1);\n  return obj1Keys.length === Object.keys(obj2).length && obj1Keys.every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\n\n////////////////////////////////////////////////////////////////////////////////\nexports.startsWith = startsWith;\nexports.pick = pick;\nexports.match = match;\nexports.resolve = resolve;\nexports.insertParams = insertParams;\nexports.validateRedirect = validateRedirect;\nexports.shallowCompare = shallowCompare;"],"mappings":"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"},"metadata":{},"sourceType":"script"}