{"ast":null,"code":"var AWS = require('../core');\n\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\n\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n\n    self.fillQueue = function () {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');\n      }\n\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' + this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function (callback) {\n    var self = this;\n    self.failed = false;\n\n    self.callback = callback || function (err) {\n      if (err) throw err;\n    };\n\n    var runFill = true;\n\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.on('error', function (err) {\n          self.cleanup(err);\n        }).on('readable', function () {\n          self.fillQueue();\n        }).on('end', function () {\n          self.isDoneChunking = true;\n          self.numParts = self.totalPartNumbers;\n          self.fillQueue.call(self);\n\n          if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n            self.finishMultiPart();\n          }\n        });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function () {\n    var self = this; //abort putObject request\n\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError',\n        retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this; // bind parameters to new service object\n\n    if (!self.service) {\n      self.service = new AWS.S3({\n        params: params\n      });\n    } else {\n      // Create a new S3 client from the supplied client's constructor.\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);\n      Object.defineProperty(self.service, '_originalConfig', {\n        get: function () {\n          return service._originalConfig;\n        },\n        enumerable: false,\n        configurable: true\n      });\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n\n    try {\n      // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) {} // try to adjust partSize if we know payload length\n\n\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n    var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();\n\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0; // if we have more than partSize, push the rest back on the queue\n\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n    var partNumber = ++self.totalPartNumbers;\n\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {\n        Body: chunk\n      };\n\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest',\n        retryable: false\n      });\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n\n    if (!self.service.config.params.UploadId) {\n      if (!self.multipartReq) {\n        // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function (resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function (err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else {\n      // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n    var partInfo = {\n      ETag: null,\n      PartNumber: partNumber\n    };\n    self.completeInfo[partNumber] = partInfo;\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function (err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing',\n          retryable: false\n        });\n      }\n\n      if (err) return self.cleanup(err); //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n\n      if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function () {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return; // clean up stream\n\n    if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    } // cleanup multipartReq listeners\n\n\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function (partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = {\n      MultipartUpload: {\n        Parts: self.completeInfo.slice(1)\n      }\n    };\n    self.service.completeMultipartUpload(completeParams, function (err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n\n        self.service.putObjectTagging({\n          Tagging: {\n            TagSet: self.tags\n          }\n        }, function (e, d) {\n          if (e) {\n            self.callback(e);\n          } else {\n            self.callback(e, data);\n          }\n        });\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n/**\n * @api private\n */\n\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n/**\n * @api private\n */\n\n\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n/**\n * @api private\n */\n\nmodule.exports = AWS.S3.ManagedUpload;","map":{"version":3,"names":["AWS","require","byteLength","util","string","Buffer","S3","ManagedUpload","inherit","constructor","options","self","SequentialExecutor","call","body","sliceFn","callback","parts","completeInfo","fillQueue","Error","configure","partSize","minPartSize","queueSize","leavePartsOnError","tags","Array","isArray","service","bindServiceObject","params","validateBody","adjustTotalBytes","maxTotalParts","send","failed","err","runFill","fillBuffer","isNode","Stream","stream","fillStream","partBuffers","on","cleanup","isDoneChunking","numParts","totalPartNumbers","doneParts","finishMultiPart","abort","singlePart","error","code","retryable","config","Body","buffer","toBuffer","arraySliceFn","copy","signatureVersion","getSignatureVersion","__super__","merge","Object","defineProperty","get","_originalConfig","enumerable","configurable","totalBytes","e","newPartSize","Math","ceil","undefined","partPos","totalChunkedBytes","totalUploadedBytes","activeParts","multipartReq","partBufferLength","bodyLen","nextChunk","endPos","min","buf","read","push","length","pbuf","concat","rest","slice","isDoneSending","chunk","partNumber","Tagging","getTaggingHeader","req","putObject","_managedUpload","progress","finishSinglePart","ContentMD5","ETag","UploadId","createMultipartUpload","resp","data","queueChunks","uploadPart","kvPairStrings","i","uriEscape","Key","Value","join","partParams","ContentLength","PartNumber","partInfo","_lastUploadedBytes","message","isBrowser","removeAllListeners","resume","abortMultipartUpload","each","part","completeParams","MultipartUpload","Parts","completeMultipartUpload","Location","replace","String","putObjectTagging","TagSet","d","upload","request","httpReq","httpRequest","endpoint","protocol","host","path","key","Bucket","info","operation","loaded","total","emit","mixin","addPromisesToClass","PromiseDependency","prototype","promise","promisifyMethod","deletePromisesFromClass","addPromises","module","exports"],"sources":["/Users/lazarbogdan/test/medicacasa-frontend/medicacasa-frontend/node_modules/aws-sdk/lib/s3/managed_upload.js"],"sourcesContent":["var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @note In Node.js, sending \"Body\" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}\n   *   may result in upload hangs. Using buffer stream is preferable.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function() {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' +\n          typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' +\n                      this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function(callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function(err) { if (err) throw err; };\n\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.\n          on('error', function(err) { self.cleanup(err); }).\n          on('readable', function() { self.fillQueue(); }).\n          on('end', function() {\n            self.isDoneChunking = true;\n            self.numParts = self.totalPartNumbers;\n            self.fillQueue.call(self);\n\n            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n              self.finishMultiPart();\n            }\n          });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function() {\n    var self = this;\n    //abort putObject request\n    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {\n      self.singlePart.abort();\n    } else {\n      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n        code: 'RequestAbortedError', retryable: false\n      }));\n    }\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = AWS.util.buffer.toBuffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({params: params});\n    } else {\n      // Create a new S3 client from the supplied client's constructor.\n      var service = self.service;\n      var config = AWS.util.copy(service.config);\n      config.signatureVersion = service.getSignatureVersion();\n      self.service = new service.constructor.__super__(config);\n      self.service.config.params =\n        AWS.util.merge(self.service.config.params || {}, params);\n      Object.defineProperty(self.service, '_originalConfig', {\n        get: function() { return service._originalConfig; },\n        enumerable: false,\n        configurable: true\n      });\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try { // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) { }\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n\n    var buf = self.body.read(self.partSize - self.partBufferLength) ||\n              self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ?\n        self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ?\n          self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {Body: chunk};\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      self.singlePart = req; //save the single part request\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest', retryable: false\n      });\n\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n\n      if (!self.multipartReq) { // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function(resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function(err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else { // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +\n        AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n\n    var partInfo = {ETag: null, PartNumber: partNumber};\n    self.completeInfo[partNumber] = partInfo;\n\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function(err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing', retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)\n      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function() {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' &&\n        typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function(partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };\n    self.service.completeMultipartUpload(completeParams, function(err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        for (var i = 0; i < self.tags.length; i++) {\n          self.tags[i].Value = String(self.tags[i].Value);\n        }\n        self.service.putObjectTagging(\n          {Tagging: {TagSet: self.tags}},\n          function(e, d) {\n            if (e) {\n              self.callback(e);\n            } else {\n              self.callback(e, data);\n            }\n          }\n        );\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location =\n      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\n\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\n/**\n * @api private\n */\nmodule.exports = AWS.S3.ManagedUpload;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}