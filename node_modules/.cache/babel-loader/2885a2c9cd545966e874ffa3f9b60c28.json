{"ast":null,"code":"(function (exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    } // Check if they are the same type.\n\n\n    var firstType = Object.prototype.toString.call(first);\n\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    } // We know that first and second have the same type so we can just check the\n    // first type from now on.\n\n\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n\n          keysSeen[key] = true;\n        }\n      } // Now check that there aren't any keys in second that weren't\n      // in first.\n\n\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n      return true;\n    } else if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    } else if (isObject(obj)) {\n      // Check for an empty object.\n      for (var key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (obj.hasOwnProperty(key)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n\n    return values;\n  }\n\n  function merge(a, b) {\n    var merged = {};\n\n    for (var key in a) {\n      merged[key] = a[key];\n    }\n\n    for (var key2 in b) {\n      merged[key2] = b[key2];\n    }\n\n    return merged;\n  }\n\n  var trimLeft;\n\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function trimLeft(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function trimLeft(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  } // Type constants used to define functions.\n\n\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>'\n  };\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN = \"Lparen\";\n  var TOK_LITERAL = \"Literal\"; // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n  var operatorStartToken = {\n    \"<\": true,\n    \">\": true,\n    \"=\": true,\n    \"!\": true\n  };\n  var skipChars = {\n    \" \": true,\n    \"\\t\": true,\n    \"\\n\": true\n  };\n\n  function isAlpha(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch === \"_\";\n  }\n\n  function isNum(ch) {\n    return ch >= \"0\" && ch <= \"9\" || ch === \"-\";\n  }\n\n  function isAlphaNum(ch) {\n    return ch >= \"a\" && ch <= \"z\" || ch >= \"A\" && ch <= \"Z\" || ch >= \"0\" && ch <= \"9\" || ch === \"_\";\n  }\n\n  function Lexer() {}\n\n  Lexer.prototype = {\n    tokenize: function tokenize(stream) {\n      var tokens = [];\n      this._current = 0;\n      var start;\n      var identifier;\n      var token;\n\n      while (this._current < stream.length) {\n        if (isAlpha(stream[this._current])) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current\n          });\n          this._current++;\n        } else if (isNum(stream[this._current])) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"[\") {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === \"\\\"\") {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start: start\n          });\n        } else if (stream[this._current] === \"`\") {\n          start = this._current;\n\n          var literal = this._consumeLiteral(stream);\n\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start: start\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current++;\n        } else if (stream[this._current] === \"&\") {\n          start = this._current;\n          this._current++;\n\n          if (stream[this._current] === \"&\") {\n            this._current++;\n            tokens.push({\n              type: TOK_AND,\n              value: \"&&\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_EXPREF,\n              value: \"&\",\n              start: start\n            });\n          }\n        } else if (stream[this._current] === \"|\") {\n          start = this._current;\n          this._current++;\n\n          if (stream[this._current] === \"|\") {\n            this._current++;\n            tokens.push({\n              type: TOK_OR,\n              value: \"||\",\n              start: start\n            });\n          } else {\n            tokens.push({\n              type: TOK_PIPE,\n              value: \"|\",\n              start: start\n            });\n          }\n        } else {\n          var error = new Error(\"Unknown character:\" + stream[this._current]);\n          error.name = \"LexerError\";\n          throw error;\n        }\n      }\n\n      return tokens;\n    },\n    _consumeUnquotedIdentifier: function _consumeUnquotedIdentifier(stream) {\n      var start = this._current;\n      this._current++;\n\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current++;\n      }\n\n      return stream.slice(start, this._current);\n    },\n    _consumeQuotedIdentifier: function _consumeQuotedIdentifier(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"\\\"\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      this._current++;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n    _consumeRawStringLiteral: function _consumeRawStringLiteral(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      this._current++;\n      var literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n    _consumeNumber: function _consumeNumber(stream) {\n      var start = this._current;\n      this._current++;\n      var maxLength = stream.length;\n\n      while (isNum(stream[this._current]) && this._current < maxLength) {\n        this._current++;\n      }\n\n      var value = parseInt(stream.slice(start, this._current));\n      return {\n        type: TOK_NUMBER,\n        value: value,\n        start: start\n      };\n    },\n    _consumeLBracket: function _consumeLBracket(stream) {\n      var start = this._current;\n      this._current++;\n\n      if (stream[this._current] === \"?\") {\n        this._current++;\n        return {\n          type: TOK_FILTER,\n          value: \"[?\",\n          start: start\n        };\n      } else if (stream[this._current] === \"]\") {\n        this._current++;\n        return {\n          type: TOK_FLATTEN,\n          value: \"[]\",\n          start: start\n        };\n      } else {\n        return {\n          type: TOK_LBRACKET,\n          value: \"[\",\n          start: start\n        };\n      }\n    },\n    _consumeOperator: function _consumeOperator(stream) {\n      var start = this._current;\n      var startingChar = stream[start];\n      this._current++;\n\n      if (startingChar === \"!\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_NE,\n            value: \"!=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_NOT,\n            value: \"!\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"<\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_LTE,\n            value: \"<=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_LT,\n            value: \"<\",\n            start: start\n          };\n        }\n      } else if (startingChar === \">\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_GTE,\n            value: \">=\",\n            start: start\n          };\n        } else {\n          return {\n            type: TOK_GT,\n            value: \">\",\n            start: start\n          };\n        }\n      } else if (startingChar === \"=\") {\n        if (stream[this._current] === \"=\") {\n          this._current++;\n          return {\n            type: TOK_EQ,\n            value: \"==\",\n            start: start\n          };\n        }\n      }\n    },\n    _consumeLiteral: function _consumeLiteral(stream) {\n      this._current++;\n      var start = this._current;\n      var maxLength = stream.length;\n      var literal;\n\n      while (stream[this._current] !== \"`\" && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        var current = this._current;\n\n        if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" || stream[current + 1] === \"`\")) {\n          current += 2;\n        } else {\n          current++;\n        }\n\n        this._current = current;\n      }\n\n      var literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace(\"\\\\`\", \"`\");\n\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n      } // +1 gets us to the ending \"`\", +1 to move on to the next char.\n\n\n      this._current++;\n      return literal;\n    },\n    _looksLikeJSON: function _looksLikeJSON(literalString) {\n      var startingChars = \"[{\\\"\";\n      var jsonLiterals = [\"true\", \"false\", \"null\"];\n      var numberLooking = \"-0123456789\";\n\n      if (literalString === \"\") {\n        return false;\n      } else if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      } else if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n  };\n  var bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {}\n\n  Parser.prototype = {\n    parse: function parse(expression) {\n      this._loadTokens(expression);\n\n      this.index = 0;\n      var ast = this.expression(0);\n\n      if (this._lookahead(0) !== TOK_EOF) {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Unexpected token type: \" + t.type + \", value: \" + t.value);\n        error.name = \"ParserError\";\n        throw error;\n      }\n\n      return ast;\n    },\n    _loadTokens: function _loadTokens(expression) {\n      var lexer = new Lexer();\n      var tokens = lexer.tokenize(expression);\n      tokens.push({\n        type: TOK_EOF,\n        value: \"\",\n        start: expression.length\n      });\n      this.tokens = tokens;\n    },\n    expression: function expression(rbp) {\n      var leftToken = this._lookaheadToken(0);\n\n      this._advance();\n\n      var left = this.nud(leftToken);\n\n      var currentToken = this._lookahead(0);\n\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n\n      return left;\n    },\n    _lookahead: function _lookahead(number) {\n      return this.tokens[this.index + number].type;\n    },\n    _lookaheadToken: function _lookaheadToken(number) {\n      return this.tokens[this.index + number];\n    },\n    _advance: function _advance() {\n      this.index++;\n    },\n    nud: function nud(token) {\n      var left;\n      var right;\n      var expression;\n\n      switch (token.type) {\n        case TOK_LITERAL:\n          return {\n            type: \"Literal\",\n            value: token.value\n          };\n\n        case TOK_UNQUOTEDIDENTIFIER:\n          return {\n            type: \"Field\",\n            name: token.value\n          };\n\n        case TOK_QUOTEDIDENTIFIER:\n          var node = {\n            type: \"Field\",\n            name: token.value\n          };\n\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error(\"Quoted identifier not allowed for function names.\");\n          }\n\n          return node;\n\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return {\n            type: \"NotExpression\",\n            children: [right]\n          };\n\n        case TOK_STAR:\n          left = {\n            type: \"Identity\"\n          };\n          right = null;\n\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n\n        case TOK_FILTER:\n          return this.led(token.type, {\n            type: \"Identity\"\n          });\n\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n\n        case TOK_FLATTEN:\n          left = {\n            type: TOK_FLATTEN,\n            children: [{\n              type: \"Identity\"\n            }]\n          };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n\n        case TOK_LBRACKET:\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({\n              type: \"Identity\"\n            }, right);\n          } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n\n            this._advance();\n\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: \"Projection\",\n              children: [{\n                type: \"Identity\"\n              }, right]\n            };\n          }\n\n          return this._parseMultiselectList();\n\n        case TOK_CURRENT:\n          return {\n            type: TOK_CURRENT\n          };\n\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return {\n            type: \"ExpressionReference\",\n            children: [expression]\n          };\n\n        case TOK_LPAREN:\n          var args = [];\n\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n\n            args.push(expression);\n          }\n\n          this._match(TOK_RPAREN);\n\n          return args[0];\n\n        default:\n          this._errorToken(token);\n\n      }\n    },\n    led: function led(tokenName, left) {\n      var right;\n\n      switch (tokenName) {\n        case TOK_DOT:\n          var rbp = bindingPower.Dot;\n\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return {\n              type: \"Subexpression\",\n              children: [left, right]\n            };\n          } // Creating a projection.\n\n\n          this._advance();\n\n          right = this._parseProjectionRHS(rbp);\n          return {\n            type: \"ValueProjection\",\n            children: [left, right]\n          };\n\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return {\n            type: TOK_PIPE,\n            children: [left, right]\n          };\n\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return {\n            type: \"OrExpression\",\n            children: [left, right]\n          };\n\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return {\n            type: \"AndExpression\",\n            children: [left, right]\n          };\n\n        case TOK_LPAREN:\n          var name = left.name;\n          var args = [];\n          var expression, node;\n\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = {\n                type: TOK_CURRENT\n              };\n\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n\n            args.push(expression);\n          }\n\n          this._match(TOK_RPAREN);\n\n          node = {\n            type: \"Function\",\n            name: name,\n            children: args\n          };\n          return node;\n\n        case TOK_FILTER:\n          var condition = this.expression(0);\n\n          this._match(TOK_RBRACKET);\n\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = {\n              type: \"Identity\"\n            };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n\n          return {\n            type: \"FilterProjection\",\n            children: [left, right, condition]\n          };\n\n        case TOK_FLATTEN:\n          var leftNode = {\n            type: TOK_FLATTEN,\n            children: [left]\n          };\n\n          var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n\n          return {\n            type: \"Projection\",\n            children: [leftNode, rightNode]\n          };\n\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n\n        case TOK_LBRACKET:\n          var token = this._lookaheadToken(0);\n\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          }\n\n          this._match(TOK_STAR);\n\n          this._match(TOK_RBRACKET);\n\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: \"Projection\",\n            children: [left, right]\n          };\n\n        default:\n          this._errorToken(this._lookaheadToken(0));\n\n      }\n    },\n    _match: function _match(tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n        error.name = \"ParserError\";\n        throw error;\n      }\n    },\n    _errorToken: function _errorToken(token) {\n      var error = new Error(\"Invalid token (\" + token.type + \"): \\\"\" + token.value + \"\\\"\");\n      error.name = \"ParserError\";\n      throw error;\n    },\n    _parseIndexExpression: function _parseIndexExpression() {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      } else {\n        var node = {\n          type: \"Index\",\n          value: this._lookaheadToken(0).value\n        };\n\n        this._advance();\n\n        this._match(TOK_RBRACKET);\n\n        return node;\n      }\n    },\n    _projectIfSlice: function _projectIfSlice(left, right) {\n      var indexExpr = {\n        type: \"IndexExpression\",\n        children: [left, right]\n      };\n\n      if (right.type === \"Slice\") {\n        return {\n          type: \"Projection\",\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n        };\n      } else {\n        return indexExpr;\n      }\n    },\n    _parseSliceExpression: function _parseSliceExpression() {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      var parts = [null, null, null];\n      var index = 0;\n\n      var currentToken = this._lookahead(0);\n\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index++;\n\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n\n          this._advance();\n        } else {\n          var t = this._lookahead(0);\n\n          var error = new Error(\"Syntax error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n          error.name = \"Parsererror\";\n          throw error;\n        }\n\n        currentToken = this._lookahead(0);\n      }\n\n      this._match(TOK_RBRACKET);\n\n      return {\n        type: \"Slice\",\n        children: parts\n      };\n    },\n    _parseComparator: function _parseComparator(left, comparator) {\n      var right = this.expression(bindingPower[comparator]);\n      return {\n        type: \"Comparator\",\n        name: comparator,\n        children: [left, right]\n      };\n    },\n    _parseDotRHS: function _parseDotRHS(rbp) {\n      var lookahead = this._lookahead(0);\n\n      var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      } else if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n\n        return this._parseMultiselectList();\n      } else if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n\n        return this._parseMultiselectHash();\n      }\n    },\n    _parseProjectionRHS: function _parseProjectionRHS(rbp) {\n      var right;\n\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = {\n          type: \"Identity\"\n        };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n\n        right = this._parseDotRHS(rbp);\n      } else {\n        var t = this._lookaheadToken(0);\n\n        var error = new Error(\"Sytanx error, unexpected token: \" + t.value + \"(\" + t.type + \")\");\n        error.name = \"ParserError\";\n        throw error;\n      }\n\n      return right;\n    },\n    _parseMultiselectList: function _parseMultiselectList() {\n      var expressions = [];\n\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        var expression = this.expression(0);\n        expressions.push(expression);\n\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error(\"Unexpected token Rbracket\");\n          }\n        }\n      }\n\n      this._match(TOK_RBRACKET);\n\n      return {\n        type: \"MultiSelectList\",\n        children: expressions\n      };\n    },\n    _parseMultiselectHash: function _parseMultiselectHash() {\n      var pairs = [];\n      var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      var keyToken, keyName, value, node;\n\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(\"Expecting an identifier token, got: \" + keyToken.type);\n        }\n\n        keyName = keyToken.value;\n\n        this._advance();\n\n        this._match(TOK_COLON);\n\n        value = this.expression(0);\n        node = {\n          type: \"KeyValuePair\",\n          name: keyName,\n          value: value\n        };\n        pairs.push(node);\n\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n\n          break;\n        }\n      }\n\n      return {\n        type: \"MultiSelectHash\",\n        children: pairs\n      };\n    }\n  };\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n    search: function search(node, value) {\n      return this.visit(node, value);\n    },\n    visit: function visit(node, value) {\n      var matched, current, result, first, second, field, left, right, collected, i;\n\n      switch (node.type) {\n        case \"Field\":\n          if (value !== null && isObject(value)) {\n            field = value[node.name];\n\n            if (field === undefined) {\n              return null;\n            } else {\n              return field;\n            }\n          }\n\n          return null;\n\n        case \"Subexpression\":\n          result = this.visit(node.children[0], value);\n\n          for (i = 1; i < node.children.length; i++) {\n            result = this.visit(node.children[1], result);\n\n            if (result === null) {\n              return null;\n            }\n          }\n\n          return result;\n\n        case \"IndexExpression\":\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n\n        case \"Index\":\n          if (!isArray(value)) {\n            return null;\n          }\n\n          var index = node.value;\n\n          if (index < 0) {\n            index = value.length + index;\n          }\n\n          result = value[index];\n\n          if (result === undefined) {\n            result = null;\n          }\n\n          return result;\n\n        case \"Slice\":\n          if (!isArray(value)) {\n            return null;\n          }\n\n          var sliceParams = node.children.slice(0);\n          var computed = this.computeSliceParams(value.length, sliceParams);\n          var start = computed[0];\n          var stop = computed[1];\n          var step = computed[2];\n          result = [];\n\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n\n          return result;\n\n        case \"Projection\":\n          // Evaluate left child.\n          var base = this.visit(node.children[0], value);\n\n          if (!isArray(base)) {\n            return null;\n          }\n\n          collected = [];\n\n          for (i = 0; i < base.length; i++) {\n            current = this.visit(node.children[1], base[i]);\n\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n\n          return collected;\n\n        case \"ValueProjection\":\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n\n          if (!isObject(base)) {\n            return null;\n          }\n\n          collected = [];\n          var values = objValues(base);\n\n          for (i = 0; i < values.length; i++) {\n            current = this.visit(node.children[1], values[i]);\n\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n\n          return collected;\n\n        case \"FilterProjection\":\n          base = this.visit(node.children[0], value);\n\n          if (!isArray(base)) {\n            return null;\n          }\n\n          var filtered = [];\n          var finalResults = [];\n\n          for (i = 0; i < base.length; i++) {\n            matched = this.visit(node.children[2], base[i]);\n\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n\n          for (var j = 0; j < filtered.length; j++) {\n            current = this.visit(node.children[1], filtered[j]);\n\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n\n          return finalResults;\n\n        case \"Comparator\":\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n\n            case TOK_GT:\n              result = first > second;\n              break;\n\n            case TOK_GTE:\n              result = first >= second;\n              break;\n\n            case TOK_LT:\n              result = first < second;\n              break;\n\n            case TOK_LTE:\n              result = first <= second;\n              break;\n\n            default:\n              throw new Error(\"Unknown comparator: \" + node.name);\n          }\n\n          return result;\n\n        case TOK_FLATTEN:\n          var original = this.visit(node.children[0], value);\n\n          if (!isArray(original)) {\n            return null;\n          }\n\n          var merged = [];\n\n          for (i = 0; i < original.length; i++) {\n            current = original[i];\n\n            if (isArray(current)) {\n              merged.push.apply(merged, current);\n            } else {\n              merged.push(current);\n            }\n          }\n\n          return merged;\n\n        case \"Identity\":\n          return value;\n\n        case \"MultiSelectList\":\n          if (value === null) {\n            return null;\n          }\n\n          collected = [];\n\n          for (i = 0; i < node.children.length; i++) {\n            collected.push(this.visit(node.children[i], value));\n          }\n\n          return collected;\n\n        case \"MultiSelectHash\":\n          if (value === null) {\n            return null;\n          }\n\n          collected = {};\n          var child;\n\n          for (i = 0; i < node.children.length; i++) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n\n          return collected;\n\n        case \"OrExpression\":\n          matched = this.visit(node.children[0], value);\n\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n\n          return matched;\n\n        case \"AndExpression\":\n          first = this.visit(node.children[0], value);\n\n          if (isFalse(first) === true) {\n            return first;\n          }\n\n          return this.visit(node.children[1], value);\n\n        case \"NotExpression\":\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n\n        case \"Literal\":\n          return node.value;\n\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n\n        case TOK_CURRENT:\n          return value;\n\n        case \"Function\":\n          var resolvedArgs = [];\n\n          for (i = 0; i < node.children.length; i++) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n\n          return this.runtime.callFunction(node.name, resolvedArgs);\n\n        case \"ExpressionReference\":\n          var refNode = node.children[0]; // Tag the node with a specific attribute so the type\n          // checker verify the type.\n\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n\n        default:\n          throw new Error(\"Unknown node type: \" + node.type);\n      }\n    },\n    computeSliceParams: function computeSliceParams(arrayLength, sliceParams) {\n      var start = sliceParams[0];\n      var stop = sliceParams[1];\n      var step = sliceParams[2];\n      var computed = [null, null, null];\n\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        var error = new Error(\"Invalid slice, step cannot be 0\");\n        error.name = \"RuntimeError\";\n        throw error;\n      }\n\n      var stepValueNegative = step < 0 ? true : false;\n\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n    capSliceRange: function capSliceRange(arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n\n      return actualValue;\n    }\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n      // name: [function, <signature>]\n      // The <signature> can be:\n      //\n      // {\n      //   args: [[type1, type2], [type1, type2]],\n      //   variadic: true|false\n      // }\n      //\n      // Each arg in the arg list is a list of valid types\n      // (if the function is overloaded and supports multiple\n      // types.  If the type is \"any\" then no type checking\n      // occurs on the argument.  Variadic is optional\n      // and if not provided is assumed to be false.\n      abs: {\n        _func: this._functionAbs,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      avg: {\n        _func: this._functionAvg,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      ceil: {\n        _func: this._functionCeil,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      contains: {\n        _func: this._functionContains,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }, {\n          types: [TYPE_ANY]\n        }]\n      },\n      \"ends_with\": {\n        _func: this._functionEndsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      floor: {\n        _func: this._functionFloor,\n        _signature: [{\n          types: [TYPE_NUMBER]\n        }]\n      },\n      length: {\n        _func: this._functionLength,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]\n        }]\n      },\n      map: {\n        _func: this._functionMap,\n        _signature: [{\n          types: [TYPE_EXPREF]\n        }, {\n          types: [TYPE_ARRAY]\n        }]\n      },\n      max: {\n        _func: this._functionMax,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"merge\": {\n        _func: this._functionMerge,\n        _signature: [{\n          types: [TYPE_OBJECT],\n          variadic: true\n        }]\n      },\n      \"max_by\": {\n        _func: this._functionMaxBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      sum: {\n        _func: this._functionSum,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"starts_with\": {\n        _func: this._functionStartsWith,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_STRING]\n        }]\n      },\n      min: {\n        _func: this._functionMin,\n        _signature: [{\n          types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]\n        }]\n      },\n      \"min_by\": {\n        _func: this._functionMinBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      type: {\n        _func: this._functionType,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      keys: {\n        _func: this._functionKeys,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      values: {\n        _func: this._functionValues,\n        _signature: [{\n          types: [TYPE_OBJECT]\n        }]\n      },\n      sort: {\n        _func: this._functionSort,\n        _signature: [{\n          types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]\n        }]\n      },\n      \"sort_by\": {\n        _func: this._functionSortBy,\n        _signature: [{\n          types: [TYPE_ARRAY]\n        }, {\n          types: [TYPE_EXPREF]\n        }]\n      },\n      join: {\n        _func: this._functionJoin,\n        _signature: [{\n          types: [TYPE_STRING]\n        }, {\n          types: [TYPE_ARRAY_STRING]\n        }]\n      },\n      reverse: {\n        _func: this._functionReverse,\n        _signature: [{\n          types: [TYPE_STRING, TYPE_ARRAY]\n        }]\n      },\n      \"to_array\": {\n        _func: this._functionToArray,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_string\": {\n        _func: this._functionToString,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"to_number\": {\n        _func: this._functionToNumber,\n        _signature: [{\n          types: [TYPE_ANY]\n        }]\n      },\n      \"not_null\": {\n        _func: this._functionNotNull,\n        _signature: [{\n          types: [TYPE_ANY],\n          variadic: true\n        }]\n      }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function callFunction(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n\n      if (functionEntry === undefined) {\n        throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n    _validateArgs: function _validateArgs(name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      var pluralized;\n\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n          throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes at least\" + signature.length + pluralized + \" but received \" + args.length);\n        }\n      } else if (args.length !== signature.length) {\n        pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n        throw new Error(\"ArgumentError: \" + name + \"() \" + \"takes \" + signature.length + pluralized + \" but received \" + args.length);\n      }\n\n      var currentSpec;\n      var actualType;\n      var typeMatched;\n\n      for (var i = 0; i < signature.length; i++) {\n        typeMatched = false;\n        currentSpec = signature[i].types;\n        actualType = this._getTypeName(args[i]);\n\n        for (var j = 0; j < currentSpec.length; j++) {\n          if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n            typeMatched = true;\n            break;\n          }\n        }\n\n        if (!typeMatched) {\n          var expected = currentSpec.map(function (typeIdentifier) {\n            return TYPE_NAME_TABLE[typeIdentifier];\n          }).join(',');\n          throw new Error(\"TypeError: \" + name + \"() \" + \"expected argument \" + (i + 1) + \" to be type \" + expected + \" but received type \" + TYPE_NAME_TABLE[actualType] + \" instead.\");\n        }\n      }\n    },\n    _typeMatches: function _typeMatches(actual, expected, argValue) {\n      if (expected === TYPE_ANY) {\n        return true;\n      }\n\n      if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {\n        // The expected type can either just be array,\n        // or it can require a specific subtype (array of numbers).\n        //\n        // The simplest case is if \"array\" with no subtype is specified.\n        if (expected === TYPE_ARRAY) {\n          return actual === TYPE_ARRAY;\n        } else if (actual === TYPE_ARRAY) {\n          // Otherwise we need to check subtypes.\n          // I think this has potential to be improved.\n          var subtype;\n\n          if (expected === TYPE_ARRAY_NUMBER) {\n            subtype = TYPE_NUMBER;\n          } else if (expected === TYPE_ARRAY_STRING) {\n            subtype = TYPE_STRING;\n          }\n\n          for (var i = 0; i < argValue.length; i++) {\n            if (!this._typeMatches(this._getTypeName(argValue[i]), subtype, argValue[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n      } else {\n        return actual === expected;\n      }\n    },\n    _getTypeName: function _getTypeName(obj) {\n      switch (Object.prototype.toString.call(obj)) {\n        case \"[object String]\":\n          return TYPE_STRING;\n\n        case \"[object Number]\":\n          return TYPE_NUMBER;\n\n        case \"[object Array]\":\n          return TYPE_ARRAY;\n\n        case \"[object Boolean]\":\n          return TYPE_BOOLEAN;\n\n        case \"[object Null]\":\n          return TYPE_NULL;\n\n        case \"[object Object]\":\n          // Check if it's an expref.  If it has, it's been\n          // tagged with a jmespathType attr of 'Expref';\n          if (obj.jmespathType === TOK_EXPREF) {\n            return TYPE_EXPREF;\n          } else {\n            return TYPE_OBJECT;\n          }\n\n      }\n    },\n    _functionStartsWith: function _functionStartsWith(resolvedArgs) {\n      return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n    _functionEndsWith: function _functionEndsWith(resolvedArgs) {\n      var searchStr = resolvedArgs[0];\n      var suffix = resolvedArgs[1];\n      return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n    _functionReverse: function _functionReverse(resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n\n      if (typeName === TYPE_STRING) {\n        var originalStr = resolvedArgs[0];\n        var reversedStr = \"\";\n\n        for (var i = originalStr.length - 1; i >= 0; i--) {\n          reversedStr += originalStr[i];\n        }\n\n        return reversedStr;\n      } else {\n        var reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      }\n    },\n    _functionAbs: function _functionAbs(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n    _functionCeil: function _functionCeil(resolvedArgs) {\n      return Math.ceil(resolvedArgs[0]);\n    },\n    _functionAvg: function _functionAvg(resolvedArgs) {\n      var sum = 0;\n      var inputArray = resolvedArgs[0];\n\n      for (var i = 0; i < inputArray.length; i++) {\n        sum += inputArray[i];\n      }\n\n      return sum / inputArray.length;\n    },\n    _functionContains: function _functionContains(resolvedArgs) {\n      return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n    _functionFloor: function _functionFloor(resolvedArgs) {\n      return Math.floor(resolvedArgs[0]);\n    },\n    _functionLength: function _functionLength(resolvedArgs) {\n      if (!isObject(resolvedArgs[0])) {\n        return resolvedArgs[0].length;\n      } else {\n        // As far as I can tell, there's no way to get the length\n        // of an object without O(n) iteration through the object.\n        return Object.keys(resolvedArgs[0]).length;\n      }\n    },\n    _functionMap: function _functionMap(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n\n      for (var i = 0; i < elements.length; i++) {\n        mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n\n      return mapped;\n    },\n    _functionMerge: function _functionMerge(resolvedArgs) {\n      var merged = {};\n\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n\n      return merged;\n    },\n    _functionMax: function _functionMax(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n\n          for (var i = 1; i < elements.length; i++) {\n            if (maxElement.localeCompare(elements[i]) < 0) {\n              maxElement = elements[i];\n            }\n          }\n\n          return maxElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionMin: function _functionMin(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n\n          for (var i = 1; i < elements.length; i++) {\n            if (elements[i].localeCompare(minElement) < 0) {\n              minElement = elements[i];\n            }\n          }\n\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n    _functionSum: function _functionSum(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n\n      return sum;\n    },\n    _functionType: function _functionType(resolvedArgs) {\n      switch (this._getTypeName(resolvedArgs[0])) {\n        case TYPE_NUMBER:\n          return \"number\";\n\n        case TYPE_STRING:\n          return \"string\";\n\n        case TYPE_ARRAY:\n          return \"array\";\n\n        case TYPE_OBJECT:\n          return \"object\";\n\n        case TYPE_BOOLEAN:\n          return \"boolean\";\n\n        case TYPE_EXPREF:\n          return \"expref\";\n\n        case TYPE_NULL:\n          return \"null\";\n      }\n    },\n    _functionKeys: function _functionKeys(resolvedArgs) {\n      return Object.keys(resolvedArgs[0]);\n    },\n    _functionValues: function _functionValues(resolvedArgs) {\n      var obj = resolvedArgs[0];\n      var keys = Object.keys(obj);\n      var values = [];\n\n      for (var i = 0; i < keys.length; i++) {\n        values.push(obj[keys[i]]);\n      }\n\n      return values;\n    },\n    _functionJoin: function _functionJoin(resolvedArgs) {\n      var joinChar = resolvedArgs[0];\n      var listJoin = resolvedArgs[1];\n      return listJoin.join(joinChar);\n    },\n    _functionToArray: function _functionToArray(resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n        return resolvedArgs[0];\n      } else {\n        return [resolvedArgs[0]];\n      }\n    },\n    _functionToString: function _functionToString(resolvedArgs) {\n      if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n        return resolvedArgs[0];\n      } else {\n        return JSON.stringify(resolvedArgs[0]);\n      }\n    },\n    _functionToNumber: function _functionToNumber(resolvedArgs) {\n      var typeName = this._getTypeName(resolvedArgs[0]);\n\n      var convertedValue;\n\n      if (typeName === TYPE_NUMBER) {\n        return resolvedArgs[0];\n      } else if (typeName === TYPE_STRING) {\n        convertedValue = +resolvedArgs[0];\n\n        if (!isNaN(convertedValue)) {\n          return convertedValue;\n        }\n      }\n\n      return null;\n    },\n    _functionNotNull: function _functionNotNull(resolvedArgs) {\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n          return resolvedArgs[i];\n        }\n      }\n\n      return null;\n    },\n    _functionSort: function _functionSort(resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n      sortedArray.sort();\n      return sortedArray;\n    },\n    _functionSortBy: function _functionSortBy(resolvedArgs) {\n      var sortedArray = resolvedArgs[0].slice(0);\n\n      if (sortedArray.length === 0) {\n        return sortedArray;\n      }\n\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[1];\n\n      var requiredType = this._getTypeName(interpreter.visit(exprefNode, sortedArray[0]));\n\n      if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n        throw new Error(\"TypeError\");\n      }\n\n      var that = this; // In order to get a stable sort out of an unstable\n      // sort algorithm, we decorate/sort/undecorate (DSU)\n      // by creating a new list of [index, element] pairs.\n      // In the cmp function, if the evaluated elements are\n      // equal, then the index will be used as the tiebreaker.\n      // After the decorated list has been sorted, it will be\n      // undecorated to extract the original elements.\n\n      var decorated = [];\n\n      for (var i = 0; i < sortedArray.length; i++) {\n        decorated.push([i, sortedArray[i]]);\n      }\n\n      decorated.sort(function (a, b) {\n        var exprA = interpreter.visit(exprefNode, a[1]);\n        var exprB = interpreter.visit(exprefNode, b[1]);\n\n        if (that._getTypeName(exprA) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprA));\n        } else if (that._getTypeName(exprB) !== requiredType) {\n          throw new Error(\"TypeError: expected \" + requiredType + \", received \" + that._getTypeName(exprB));\n        }\n\n        if (exprA > exprB) {\n          return 1;\n        } else if (exprA < exprB) {\n          return -1;\n        } else {\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        }\n      }); // Undecorate: extract out the original list elements.\n\n      for (var j = 0; j < decorated.length; j++) {\n        sortedArray[j] = decorated[j][1];\n      }\n\n      return sortedArray;\n    },\n    _functionMaxBy: function _functionMaxBy(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n\n      return maxRecord;\n    },\n    _functionMinBy: function _functionMinBy(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n\n      return minRecord;\n    },\n    createKeyFunction: function createKeyFunction(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n\n      var keyFunc = function keyFunc(x) {\n        var current = interpreter.visit(exprefNode, x);\n\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes + \", received \" + that._getTypeName(current);\n\n          throw new Error(msg);\n        }\n\n        return current;\n      };\n\n      return keyFunc;\n    }\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n    var lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n    var parser = new Parser(); // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n\n    var runtime = new Runtime();\n    var interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    var node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);","map":{"version":3,"names":["exports","isArray","obj","Object","prototype","toString","call","isObject","strictDeepEqual","first","second","firstType","length","i","keysSeen","key","hasOwnProperty","key2","isFalse","objValues","keys","values","push","merge","a","b","merged","trimLeft","String","str","match","TYPE_NUMBER","TYPE_ANY","TYPE_STRING","TYPE_ARRAY","TYPE_OBJECT","TYPE_BOOLEAN","TYPE_EXPREF","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TYPE_NAME_TABLE","TOK_EOF","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_EQ","TOK_GT","TOK_LT","TOK_GTE","TOK_LTE","TOK_NE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_NOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","basicTokens","operatorStartToken","skipChars","isAlpha","ch","isNum","isAlphaNum","Lexer","tokenize","stream","tokens","_current","start","identifier","token","_consumeUnquotedIdentifier","type","value","undefined","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","error","Error","name","slice","maxLength","current","JSON","parse","replace","parseInt","startingChar","literalString","_looksLikeJSON","startingChars","jsonLiterals","numberLooking","indexOf","ex","bindingPower","Parser","expression","_loadTokens","index","ast","_lookahead","t","_lookaheadToken","lexer","rbp","leftToken","_advance","left","nud","currentToken","led","number","right","node","Not","children","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseIndexExpression","_projectIfSlice","_parseMultiselectList","Expref","args","_match","_errorToken","tokenName","Dot","_parseDotRHS","Pipe","Or","And","condition","Filter","leftNode","rightNode","_parseComparator","tokenType","_parseSliceExpression","indexExpr","parts","comparator","lookahead","exprTokens","expressions","pairs","identifierTypes","keyToken","keyName","TreeInterpreter","runtime","search","visit","matched","result","field","collected","sliceParams","computed","computeSliceParams","stop","step","base","filtered","finalResults","j","original","apply","child","resolvedArgs","callFunction","refNode","jmespathType","arrayLength","stepValueNegative","capSliceRange","actualValue","Runtime","interpreter","_interpreter","functionTable","abs","_func","_functionAbs","_signature","types","avg","_functionAvg","ceil","_functionCeil","contains","_functionContains","_functionEndsWith","floor","_functionFloor","_functionLength","map","_functionMap","max","_functionMax","_functionMerge","variadic","_functionMaxBy","sum","_functionSum","_functionStartsWith","min","_functionMin","_functionMinBy","_functionType","_functionKeys","_functionValues","sort","_functionSort","_functionSortBy","join","_functionJoin","reverse","_functionReverse","_functionToArray","_functionToString","_functionToNumber","_functionNotNull","functionEntry","_validateArgs","signature","pluralized","currentSpec","actualType","typeMatched","_getTypeName","_typeMatches","expected","typeIdentifier","actual","argValue","subtype","lastIndexOf","searchStr","suffix","typeName","originalStr","reversedStr","reversedArray","Math","inputArray","mapped","exprefNode","elements","maxElement","localeCompare","minElement","listToSum","joinChar","listJoin","stringify","convertedValue","isNaN","sortedArray","requiredType","that","decorated","exprA","exprB","resolvedArray","keyFunction","createKeyFunction","maxNumber","Infinity","maxRecord","minNumber","minRecord","allowedTypes","keyFunc","x","msg","compile","parser","data","jmespath"],"sources":["/Users/lazarbogdan/test/medicacasa-frontend/medicacasa-frontend/node_modules/jmespath/jmespath.js"],"sourcesContent":["(function(exports) {\n  \"use strict\";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(obj) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n\n    // First check the scalar values.\n    if (obj === \"\" || obj === false || obj === null) {\n        return true;\n    } else if (isArray(obj) && obj.length === 0) {\n        // Check for an empty array.\n        return true;\n    } else if (isObject(obj)) {\n        // Check for an empty object.\n        for (var key in obj) {\n            // If there are any keys, then\n            // the object is not empty so the object\n            // is not false.\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function merge(a, b) {\n      var merged = {};\n      for (var key in a) {\n          merged[key] = a[key];\n      }\n      for (var key2 in b) {\n          merged[key2] = b[key2];\n      }\n      return merged;\n  }\n\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === \"function\") {\n    trimLeft = function(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  // Type constants used to define functions.\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n  var TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>'\n  };\n\n  var TOK_EOF = \"EOF\";\n  var TOK_UNQUOTEDIDENTIFIER = \"UnquotedIdentifier\";\n  var TOK_QUOTEDIDENTIFIER = \"QuotedIdentifier\";\n  var TOK_RBRACKET = \"Rbracket\";\n  var TOK_RPAREN = \"Rparen\";\n  var TOK_COMMA = \"Comma\";\n  var TOK_COLON = \"Colon\";\n  var TOK_RBRACE = \"Rbrace\";\n  var TOK_NUMBER = \"Number\";\n  var TOK_CURRENT = \"Current\";\n  var TOK_EXPREF = \"Expref\";\n  var TOK_PIPE = \"Pipe\";\n  var TOK_OR = \"Or\";\n  var TOK_AND = \"And\";\n  var TOK_EQ = \"EQ\";\n  var TOK_GT = \"GT\";\n  var TOK_LT = \"LT\";\n  var TOK_GTE = \"GTE\";\n  var TOK_LTE = \"LTE\";\n  var TOK_NE = \"NE\";\n  var TOK_FLATTEN = \"Flatten\";\n  var TOK_STAR = \"Star\";\n  var TOK_FILTER = \"Filter\";\n  var TOK_DOT = \"Dot\";\n  var TOK_NOT = \"Not\";\n  var TOK_LBRACE = \"Lbrace\";\n  var TOK_LBRACKET = \"Lbracket\";\n  var TOK_LPAREN= \"Lparen\";\n  var TOK_LITERAL= \"Literal\";\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  var basicTokens = {\n    \".\": TOK_DOT,\n    \"*\": TOK_STAR,\n    \",\": TOK_COMMA,\n    \":\": TOK_COLON,\n    \"{\": TOK_LBRACE,\n    \"}\": TOK_RBRACE,\n    \"]\": TOK_RBRACKET,\n    \"(\": TOK_LPAREN,\n    \")\": TOK_RPAREN,\n    \"@\": TOK_CURRENT\n  };\n\n  var operatorStartToken = {\n      \"<\": true,\n      \">\": true,\n      \"=\": true,\n      \"!\": true\n  };\n\n  var skipChars = {\n      \" \": true,\n      \"\\t\": true,\n      \"\\n\": true\n  };\n\n\n  function isAlpha(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             ch === \"_\";\n  }\n\n  function isNum(ch) {\n      return (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"-\";\n  }\n  function isAlphaNum(ch) {\n      return (ch >= \"a\" && ch <= \"z\") ||\n             (ch >= \"A\" && ch <= \"Z\") ||\n             (ch >= \"0\" && ch <= \"9\") ||\n             ch === \"_\";\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n      tokenize: function(stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n          while (this._current < stream.length) {\n              if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({type: basicTokens[stream[this._current]],\n                              value: stream[this._current],\n                              start: this._current});\n                  this._current++;\n              } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"[\") {\n                  // No need to increment this._current.  This happens\n                  // in _consumeLBracket\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === \"\\\"\") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({type: TOK_QUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"'\") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === \"`\") {\n                  start = this._current;\n                  var literal = this._consumeLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: literal,\n                               start: start});\n              } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n              } else if (skipChars[stream[this._current]] !== undefined) {\n                  // Ignore whitespace.\n                  this._current++;\n              } else if (stream[this._current] === \"&\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"&\") {\n                      this._current++;\n                      tokens.push({type: TOK_AND, value: \"&&\", start: start});\n                  } else {\n                      tokens.push({type: TOK_EXPREF, value: \"&\", start: start});\n                  }\n              } else if (stream[this._current] === \"|\") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === \"|\") {\n                      this._current++;\n                      tokens.push({type: TOK_OR, value: \"||\", start: start});\n                  } else {\n                      tokens.push({type: TOK_PIPE, value: \"|\", start: start});\n                  }\n              } else {\n                  var error = new Error(\"Unknown character:\" + stream[this._current]);\n                  error.name = \"LexerError\";\n                  throw error;\n              }\n          }\n          return tokens;\n      },\n\n      _consumeUnquotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n              this._current++;\n          }\n          return stream.slice(start, this._current);\n      },\n\n      _consumeQuotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"\\\"\" && this._current < maxLength) {\n              // You can escape a double quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"\\\"\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n      },\n\n      _consumeRawStringLiteral: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== \"'\" && this._current < maxLength) {\n              // You can escape a single quote and you can escape an escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"'\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace(\"\\\\'\", \"'\");\n      },\n\n      _consumeNumber: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n              this._current++;\n          }\n          var value = parseInt(stream.slice(start, this._current));\n          return {type: TOK_NUMBER, value: value, start: start};\n      },\n\n      _consumeLBracket: function(stream) {\n          var start = this._current;\n          this._current++;\n          if (stream[this._current] === \"?\") {\n              this._current++;\n              return {type: TOK_FILTER, value: \"[?\", start: start};\n          } else if (stream[this._current] === \"]\") {\n              this._current++;\n              return {type: TOK_FLATTEN, value: \"[]\", start: start};\n          } else {\n              return {type: TOK_LBRACKET, value: \"[\", start: start};\n          }\n      },\n\n      _consumeOperator: function(stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n          if (startingChar === \"!\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_NE, value: \"!=\", start: start};\n              } else {\n                return {type: TOK_NOT, value: \"!\", start: start};\n              }\n          } else if (startingChar === \"<\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_LTE, value: \"<=\", start: start};\n              } else {\n                  return {type: TOK_LT, value: \"<\", start: start};\n              }\n          } else if (startingChar === \">\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_GTE, value: \">=\", start: start};\n              } else {\n                  return {type: TOK_GT, value: \">\", start: start};\n              }\n          } else if (startingChar === \"=\") {\n              if (stream[this._current] === \"=\") {\n                  this._current++;\n                  return {type: TOK_EQ, value: \"==\", start: start};\n              }\n          }\n      },\n\n      _consumeLiteral: function(stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n          while(stream[this._current] !== \"`\" && this._current < maxLength) {\n              // You can escape a literal char or you can escape the escape.\n              var current = this._current;\n              if (stream[current] === \"\\\\\" && (stream[current + 1] === \"\\\\\" ||\n                                               stream[current + 1] === \"`\")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace(\"\\\\`\", \"`\");\n          if (this._looksLikeJSON(literalString)) {\n              literal = JSON.parse(literalString);\n          } else {\n              // Try to JSON parse it as \"<literal>\"\n              literal = JSON.parse(\"\\\"\" + literalString + \"\\\"\");\n          }\n          // +1 gets us to the ending \"`\", +1 to move on to the next char.\n          this._current++;\n          return literal;\n      },\n\n      _looksLikeJSON: function(literalString) {\n          var startingChars = \"[{\\\"\";\n          var jsonLiterals = [\"true\", \"false\", \"null\"];\n          var numberLooking = \"-0123456789\";\n\n          if (literalString === \"\") {\n              return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n              return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n              return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n              try {\n                  JSON.parse(literalString);\n                  return true;\n              } catch (ex) {\n                  return false;\n              }\n          } else {\n              return false;\n          }\n      }\n  };\n\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n      parse: function(expression) {\n          this._loadTokens(expression);\n          this.index = 0;\n          var ast = this.expression(0);\n          if (this._lookahead(0) !== TOK_EOF) {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\n                  \"Unexpected token type: \" + t.type + \", value: \" + t.value);\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return ast;\n      },\n\n      _loadTokens: function(expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({type: TOK_EOF, value: \"\", start: expression.length});\n          this.tokens = tokens;\n      },\n\n      expression: function(rbp) {\n          var leftToken = this._lookaheadToken(0);\n          this._advance();\n          var left = this.nud(leftToken);\n          var currentToken = this._lookahead(0);\n          while (rbp < bindingPower[currentToken]) {\n              this._advance();\n              left = this.led(currentToken, left);\n              currentToken = this._lookahead(0);\n          }\n          return left;\n      },\n\n      _lookahead: function(number) {\n          return this.tokens[this.index + number].type;\n      },\n\n      _lookaheadToken: function(number) {\n          return this.tokens[this.index + number];\n      },\n\n      _advance: function() {\n          this.index++;\n      },\n\n      nud: function(token) {\n        var left;\n        var right;\n        var expression;\n        switch (token.type) {\n          case TOK_LITERAL:\n            return {type: \"Literal\", value: token.value};\n          case TOK_UNQUOTEDIDENTIFIER:\n            return {type: \"Field\", name: token.value};\n          case TOK_QUOTEDIDENTIFIER:\n            var node = {type: \"Field\", name: token.value};\n            if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error(\"Quoted identifier not allowed for function names.\");\n            }\n            return node;\n          case TOK_NOT:\n            right = this.expression(bindingPower.Not);\n            return {type: \"NotExpression\", children: [right]};\n          case TOK_STAR:\n            left = {type: \"Identity\"};\n            right = null;\n            if (this._lookahead(0) === TOK_RBRACKET) {\n                // This can happen in a multiselect,\n                // [a, b, *]\n                right = {type: \"Identity\"};\n            } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n            }\n            return {type: \"ValueProjection\", children: [left, right]};\n          case TOK_FILTER:\n            return this.led(token.type, {type: \"Identity\"});\n          case TOK_LBRACE:\n            return this._parseMultiselectHash();\n          case TOK_FLATTEN:\n            left = {type: TOK_FLATTEN, children: [{type: \"Identity\"}]};\n            right = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [left, right]};\n          case TOK_LBRACKET:\n            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({type: \"Identity\"}, right);\n            } else if (this._lookahead(0) === TOK_STAR &&\n                       this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n                this._advance();\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: \"Projection\",\n                        children: [{type: \"Identity\"}, right]};\n            }\n            return this._parseMultiselectList();\n          case TOK_CURRENT:\n            return {type: TOK_CURRENT};\n          case TOK_EXPREF:\n            expression = this.expression(bindingPower.Expref);\n            return {type: \"ExpressionReference\", children: [expression]};\n          case TOK_LPAREN:\n            var args = [];\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            return args[0];\n          default:\n            this._errorToken(token);\n        }\n      },\n\n      led: function(tokenName, left) {\n        var right;\n        switch(tokenName) {\n          case TOK_DOT:\n            var rbp = bindingPower.Dot;\n            if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {type: \"Subexpression\", children: [left, right]};\n            }\n            // Creating a projection.\n            this._advance();\n            right = this._parseProjectionRHS(rbp);\n            return {type: \"ValueProjection\", children: [left, right]};\n          case TOK_PIPE:\n            right = this.expression(bindingPower.Pipe);\n            return {type: TOK_PIPE, children: [left, right]};\n          case TOK_OR:\n            right = this.expression(bindingPower.Or);\n            return {type: \"OrExpression\", children: [left, right]};\n          case TOK_AND:\n            right = this.expression(bindingPower.And);\n            return {type: \"AndExpression\", children: [left, right]};\n          case TOK_LPAREN:\n            var name = left.name;\n            var args = [];\n            var expression, node;\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              if (this._lookahead(0) === TOK_COMMA) {\n                this._match(TOK_COMMA);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            node = {type: \"Function\", name: name, children: args};\n            return node;\n          case TOK_FILTER:\n            var condition = this.expression(0);\n            this._match(TOK_RBRACKET);\n            if (this._lookahead(0) === TOK_FLATTEN) {\n              right = {type: \"Identity\"};\n            } else {\n              right = this._parseProjectionRHS(bindingPower.Filter);\n            }\n            return {type: \"FilterProjection\", children: [left, right, condition]};\n          case TOK_FLATTEN:\n            var leftNode = {type: TOK_FLATTEN, children: [left]};\n            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: \"Projection\", children: [leftNode, rightNode]};\n          case TOK_EQ:\n          case TOK_NE:\n          case TOK_GT:\n          case TOK_GTE:\n          case TOK_LT:\n          case TOK_LTE:\n            return this._parseComparator(left, tokenName);\n          case TOK_LBRACKET:\n            var token = this._lookaheadToken(0);\n            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n            }\n            this._match(TOK_STAR);\n            this._match(TOK_RBRACKET);\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {type: \"Projection\", children: [left, right]};\n          default:\n            this._errorToken(this._lookaheadToken(0));\n        }\n      },\n\n      _match: function(tokenType) {\n          if (this._lookahead(0) === tokenType) {\n              this._advance();\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Expected \" + tokenType + \", got: \" + t.type);\n              error.name = \"ParserError\";\n              throw error;\n          }\n      },\n\n      _errorToken: function(token) {\n          var error = new Error(\"Invalid token (\" +\n                                token.type + \"): \\\"\" +\n                                token.value + \"\\\"\");\n          error.name = \"ParserError\";\n          throw error;\n      },\n\n\n      _parseIndexExpression: function() {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n              return this._parseSliceExpression();\n          } else {\n              var node = {\n                  type: \"Index\",\n                  value: this._lookaheadToken(0).value};\n              this._advance();\n              this._match(TOK_RBRACKET);\n              return node;\n          }\n      },\n\n      _projectIfSlice: function(left, right) {\n          var indexExpr = {type: \"IndexExpression\", children: [left, right]};\n          if (right.type === \"Slice\") {\n              return {\n                  type: \"Projection\",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n              };\n          } else {\n              return indexExpr;\n          }\n      },\n\n      _parseSliceExpression: function() {\n          // [start:end:step] where each part is optional, as well as the last\n          // colon.\n          var parts = [null, null, null];\n          var index = 0;\n          var currentToken = this._lookahead(0);\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n              if (currentToken === TOK_COLON) {\n                  index++;\n                  this._advance();\n              } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n                  this._advance();\n              } else {\n                  var t = this._lookahead(0);\n                  var error = new Error(\"Syntax error, unexpected token: \" +\n                                        t.value + \"(\" + t.type + \")\");\n                  error.name = \"Parsererror\";\n                  throw error;\n              }\n              currentToken = this._lookahead(0);\n          }\n          this._match(TOK_RBRACKET);\n          return {\n              type: \"Slice\",\n              children: parts\n          };\n      },\n\n      _parseComparator: function(left, comparator) {\n        var right = this.expression(bindingPower[comparator]);\n        return {type: \"Comparator\", name: comparator, children: [left, right]};\n      },\n\n      _parseDotRHS: function(rbp) {\n          var lookahead = this._lookahead(0);\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n          if (exprTokens.indexOf(lookahead) >= 0) {\n              return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n              this._match(TOK_LBRACKET);\n              return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n              this._match(TOK_LBRACE);\n              return this._parseMultiselectHash();\n          }\n      },\n\n      _parseProjectionRHS: function(rbp) {\n          var right;\n          if (bindingPower[this._lookahead(0)] < 10) {\n              right = {type: \"Identity\"};\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n              this._match(TOK_DOT);\n              right = this._parseDotRHS(rbp);\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\"Sytanx error, unexpected token: \" +\n                                    t.value + \"(\" + t.type + \")\");\n              error.name = \"ParserError\";\n              throw error;\n          }\n          return right;\n      },\n\n      _parseMultiselectList: function() {\n          var expressions = [];\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n              var expression = this.expression(0);\n              expressions.push(expression);\n              if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error(\"Unexpected token Rbracket\");\n                  }\n              }\n          }\n          this._match(TOK_RBRACKET);\n          return {type: \"MultiSelectList\", children: expressions};\n      },\n\n      _parseMultiselectHash: function() {\n        var pairs = [];\n        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n        var keyToken, keyName, value, node;\n        for (;;) {\n          keyToken = this._lookaheadToken(0);\n          if (identifierTypes.indexOf(keyToken.type) < 0) {\n            throw new Error(\"Expecting an identifier token, got: \" +\n                            keyToken.type);\n          }\n          keyName = keyToken.value;\n          this._advance();\n          this._match(TOK_COLON);\n          value = this.expression(0);\n          node = {type: \"KeyValuePair\", name: keyName, value: value};\n          pairs.push(node);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          } else if (this._lookahead(0) === TOK_RBRACE) {\n            this._match(TOK_RBRACE);\n            break;\n          }\n        }\n        return {type: \"MultiSelectHash\", children: pairs};\n      }\n  };\n\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n      search: function(node, value) {\n          return this.visit(node, value);\n      },\n\n      visit: function(node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n          switch (node.type) {\n            case \"Field\":\n              if (value !== null && isObject(value)) {\n                  field = value[node.name];\n                  if (field === undefined) {\n                      return null;\n                  } else {\n                      return field;\n                  }\n              }\n              return null;\n            case \"Subexpression\":\n              result = this.visit(node.children[0], value);\n              for (i = 1; i < node.children.length; i++) {\n                  result = this.visit(node.children[1], result);\n                  if (result === null) {\n                      return null;\n                  }\n              }\n              return result;\n            case \"IndexExpression\":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n            case \"Index\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var index = node.value;\n              if (index < 0) {\n                index = value.length + index;\n              }\n              result = value[index];\n              if (result === undefined) {\n                result = null;\n              }\n              return result;\n            case \"Slice\":\n              if (!isArray(value)) {\n                return null;\n              }\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n              if (step > 0) {\n                  for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                  }\n              } else {\n                  for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                  }\n              }\n              return result;\n            case \"Projection\":\n              // Evaluate left child.\n              var base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"ValueProjection\":\n              // Evaluate left child.\n              base = this.visit(node.children[0], value);\n              if (!isObject(base)) {\n                return null;\n              }\n              collected = [];\n              var values = objValues(base);\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case \"FilterProjection\":\n              base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              var filtered = [];\n              var finalResults = [];\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n              return finalResults;\n            case \"Comparator\":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n              switch(node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n                case TOK_GT:\n                  result = first > second;\n                  break;\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n                case TOK_LT:\n                  result = first < second;\n                  break;\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n                default:\n                  throw new Error(\"Unknown comparator: \" + node.name);\n              }\n              return result;\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n              if (!isArray(original)) {\n                return null;\n              }\n              var merged = [];\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n              return merged;\n            case \"Identity\":\n              return value;\n            case \"MultiSelectList\":\n              if (value === null) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < node.children.length; i++) {\n                  collected.push(this.visit(node.children[i], value));\n              }\n              return collected;\n            case \"MultiSelectHash\":\n              if (value === null) {\n                return null;\n              }\n              collected = {};\n              var child;\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n              return collected;\n            case \"OrExpression\":\n              matched = this.visit(node.children[0], value);\n              if (isFalse(matched)) {\n                  matched = this.visit(node.children[1], value);\n              }\n              return matched;\n            case \"AndExpression\":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n              return this.visit(node.children[1], value);\n            case \"NotExpression\":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n            case \"Literal\":\n              return node.value;\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n            case TOK_CURRENT:\n              return value;\n            case \"Function\":\n              var resolvedArgs = [];\n              for (i = 0; i < node.children.length; i++) {\n                  resolvedArgs.push(this.visit(node.children[i], value));\n              }\n              return this.runtime.callFunction(node.name, resolvedArgs);\n            case \"ExpressionReference\":\n              var refNode = node.children[0];\n              // Tag the node with a specific attribute so the type\n              // checker verify the type.\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n            default:\n              throw new Error(\"Unknown node type: \" + node.type);\n          }\n      },\n\n      computeSliceParams: function(arrayLength, sliceParams) {\n        var start = sliceParams[0];\n        var stop = sliceParams[1];\n        var step = sliceParams[2];\n        var computed = [null, null, null];\n        if (step === null) {\n          step = 1;\n        } else if (step === 0) {\n          var error = new Error(\"Invalid slice, step cannot be 0\");\n          error.name = \"RuntimeError\";\n          throw error;\n        }\n        var stepValueNegative = step < 0 ? true : false;\n\n        if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n        } else {\n            start = this.capSliceRange(arrayLength, start, step);\n        }\n\n        if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n        } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n        }\n        computed[0] = start;\n        computed[1] = stop;\n        computed[2] = step;\n        return computed;\n      },\n\n      capSliceRange: function(arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n              actualValue += arrayLength;\n              if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n              }\n          } else if (actualValue >= arrayLength) {\n              actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n          return actualValue;\n      }\n\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n        // name: [function, <signature>]\n        // The <signature> can be:\n        //\n        // {\n        //   args: [[type1, type2], [type1, type2]],\n        //   variadic: true|false\n        // }\n        //\n        // Each arg in the arg list is a list of valid types\n        // (if the function is overloaded and supports multiple\n        // types.  If the type is \"any\" then no type checking\n        // occurs on the argument.  Variadic is optional\n        // and if not provided is assumed to be false.\n        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},\n        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},\n        contains: {\n            _func: this._functionContains,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},\n                        {types: [TYPE_ANY]}]},\n        \"ends_with\": {\n            _func: this._functionEndsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},\n        length: {\n            _func: this._functionLength,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},\n        map: {\n            _func: this._functionMap,\n            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},\n        max: {\n            _func: this._functionMax,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"merge\": {\n            _func: this._functionMerge,\n            _signature: [{types: [TYPE_OBJECT], variadic: true}]\n        },\n        \"max_by\": {\n          _func: this._functionMaxBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        \"starts_with\": {\n            _func: this._functionStartsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        min: {\n            _func: this._functionMin,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        \"min_by\": {\n          _func: this._functionMinBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},\n        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},\n        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},\n        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},\n        \"sort_by\": {\n          _func: this._functionSortBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        join: {\n            _func: this._functionJoin,\n            _signature: [\n                {types: [TYPE_STRING]},\n                {types: [TYPE_ARRAY_STRING]}\n            ]\n        },\n        reverse: {\n            _func: this._functionReverse,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},\n        \"to_array\": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},\n        \"to_string\": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},\n        \"to_number\": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},\n        \"not_null\": {\n            _func: this._functionNotNull,\n            _signature: [{types: [TYPE_ANY], variadic: true}]\n        }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n          throw new Error(\"Unknown function: \" + name + \"()\");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs: function(name, args, signature) {\n        // Validating the args requires validating\n        // the correct arity and the correct type of each arg.\n        // If the last argument is declared as variadic, then we need\n        // a minimum number of args to be required.  Otherwise it has to\n        // be an exact amount.\n        var pluralized;\n        if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n                pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n                throw new Error(\"ArgumentError: \" + name + \"() \" +\n                                \"takes at least\" + signature.length + pluralized +\n                                \" but received \" + args.length);\n            }\n        } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? \" argument\" : \" arguments\";\n            throw new Error(\"ArgumentError: \" + name + \"() \" +\n                            \"takes \" + signature.length + pluralized +\n                            \" but received \" + args.length);\n        }\n        var currentSpec;\n        var actualType;\n        var typeMatched;\n        for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n            for (var j = 0; j < currentSpec.length; j++) {\n                if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                }\n            }\n            if (!typeMatched) {\n                var expected = currentSpec\n                    .map(function(typeIdentifier) {\n                        return TYPE_NAME_TABLE[typeIdentifier];\n                    })\n                    .join(',');\n                throw new Error(\"TypeError: \" + name + \"() \" +\n                                \"expected argument \" + (i + 1) +\n                                \" to be type \" + expected +\n                                \" but received type \" +\n                                TYPE_NAME_TABLE[actualType] + \" instead.\");\n            }\n        }\n    },\n\n    _typeMatches: function(actual, expected, argValue) {\n        if (expected === TYPE_ANY) {\n            return true;\n        }\n        if (expected === TYPE_ARRAY_STRING ||\n            expected === TYPE_ARRAY_NUMBER ||\n            expected === TYPE_ARRAY) {\n            // The expected type can either just be array,\n            // or it can require a specific subtype (array of numbers).\n            //\n            // The simplest case is if \"array\" with no subtype is specified.\n            if (expected === TYPE_ARRAY) {\n                return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n                // Otherwise we need to check subtypes.\n                // I think this has potential to be improved.\n                var subtype;\n                if (expected === TYPE_ARRAY_NUMBER) {\n                  subtype = TYPE_NUMBER;\n                } else if (expected === TYPE_ARRAY_STRING) {\n                  subtype = TYPE_STRING;\n                }\n                for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(\n                            this._getTypeName(argValue[i]), subtype,\n                                             argValue[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } else {\n            return actual === expected;\n        }\n    },\n    _getTypeName: function(obj) {\n        switch (Object.prototype.toString.call(obj)) {\n            case \"[object String]\":\n              return TYPE_STRING;\n            case \"[object Number]\":\n              return TYPE_NUMBER;\n            case \"[object Array]\":\n              return TYPE_ARRAY;\n            case \"[object Boolean]\":\n              return TYPE_BOOLEAN;\n            case \"[object Null]\":\n              return TYPE_NULL;\n            case \"[object Object]\":\n              // Check if it's an expref.  If it has, it's been\n              // tagged with a jmespathType attr of 'Expref';\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n        }\n    },\n\n    _functionStartsWith: function(resolvedArgs) {\n        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n\n    _functionEndsWith: function(resolvedArgs) {\n        var searchStr = resolvedArgs[0];\n        var suffix = resolvedArgs[1];\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_STRING) {\n          var originalStr = resolvedArgs[0];\n          var reversedStr = \"\";\n          for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        } else {\n          var reversedArray = resolvedArgs[0].slice(0);\n          reversedArray.reverse();\n          return reversedArray;\n        }\n    },\n\n    _functionAbs: function(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil: function(resolvedArgs) {\n        return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg: function(resolvedArgs) {\n        var sum = 0;\n        var inputArray = resolvedArgs[0];\n        for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n    },\n\n    _functionContains: function(resolvedArgs) {\n        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n\n    _functionFloor: function(resolvedArgs) {\n        return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength: function(resolvedArgs) {\n       if (!isObject(resolvedArgs[0])) {\n         return resolvedArgs[0].length;\n       } else {\n         // As far as I can tell, there's no way to get the length\n         // of an object without O(n) iteration through the object.\n         return Object.keys(resolvedArgs[0]).length;\n       }\n    },\n\n    _functionMap: function(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge: function(resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n\n    _functionMax: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n              }\n          }\n          return maxElement;\n        }\n      } else {\n          return null;\n      }\n    },\n\n    _functionMin: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n              }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n\n    _functionSum: function(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n\n    _functionType: function(resolvedArgs) {\n        switch (this._getTypeName(resolvedArgs[0])) {\n          case TYPE_NUMBER:\n            return \"number\";\n          case TYPE_STRING:\n            return \"string\";\n          case TYPE_ARRAY:\n            return \"array\";\n          case TYPE_OBJECT:\n            return \"object\";\n          case TYPE_BOOLEAN:\n            return \"boolean\";\n          case TYPE_EXPREF:\n            return \"expref\";\n          case TYPE_NULL:\n            return \"null\";\n        }\n    },\n\n    _functionKeys: function(resolvedArgs) {\n        return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues: function(resolvedArgs) {\n        var obj = resolvedArgs[0];\n        var keys = Object.keys(obj);\n        var values = [];\n        for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n        }\n        return values;\n    },\n\n    _functionJoin: function(resolvedArgs) {\n        var joinChar = resolvedArgs[0];\n        var listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n    },\n\n    _functionToArray: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n        } else {\n            return [resolvedArgs[0]];\n        }\n    },\n\n    _functionToString: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n        } else {\n            return JSON.stringify(resolvedArgs[0]);\n        }\n    },\n\n    _functionToNumber: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        var convertedValue;\n        if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n        } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n            if (!isNaN(convertedValue)) {\n                return convertedValue;\n            }\n        }\n        return null;\n    },\n\n    _functionNotNull: function(resolvedArgs) {\n        for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                return resolvedArgs[i];\n            }\n        }\n        return null;\n    },\n\n    _functionSort: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        sortedArray.sort();\n        return sortedArray;\n    },\n\n    _functionSortBy: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n            return sortedArray;\n        }\n        var interpreter = this._interpreter;\n        var exprefNode = resolvedArgs[1];\n        var requiredType = this._getTypeName(\n            interpreter.visit(exprefNode, sortedArray[0]));\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error(\"TypeError\");\n        }\n        var that = this;\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        var decorated = [];\n        for (var i = 0; i < sortedArray.length; i++) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort(function(a, b) {\n          var exprA = interpreter.visit(exprefNode, a[1]);\n          var exprB = interpreter.visit(exprefNode, b[1]);\n          if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprA));\n          } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\n                  \"TypeError: expected \" + requiredType + \", received \" +\n                  that._getTypeName(exprB));\n          }\n          if (exprA > exprB) {\n            return 1;\n          } else if (exprA < exprB) {\n            return -1;\n          } else {\n            // If they're equal compare the items by their\n            // order to maintain relative order of equal keys\n            // (i.e. to get a stable sort).\n            return a[0] - b[0];\n          }\n        });\n        // Undecorate: extract out the original list elements.\n        for (var j = 0; j < decorated.length; j++) {\n          sortedArray[j] = decorated[j][1];\n        }\n        return sortedArray;\n    },\n\n    _functionMaxBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction: function(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function(x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = \"TypeError: expected one of \" + allowedTypes +\n                    \", received \" + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n      var lexer = new Lexer();\n      return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n      var parser = new Parser();\n      // This needs to be improved.  Both the interpreter and runtime depend on\n      // each other.  The runtime needs the interpreter to support exprefs.\n      // There's likely a clean way to avoid the cyclic dependency.\n      var runtime = new Runtime();\n      var interpreter = new TreeInterpreter(runtime);\n      runtime._interpreter = interpreter;\n      var node = parser.parse(expression);\n      return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === \"undefined\" ? this.jmespath = {} : exports);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}