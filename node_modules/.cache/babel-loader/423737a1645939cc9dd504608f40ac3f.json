{"ast":null,"code":"var parseMessage = require('./parse-message').parseMessage;\n/**\n *\n * @param {*} parser\n * @param {Buffer} message\n * @param {*} shape\n * @api private\n */\n\n\nfunction parseEvent(parser, message, shape) {\n  var parsedMessage = parseMessage(message); // check if message is an event or error\n\n  var messageType = parsedMessage.headers[':message-type'];\n\n  if (messageType) {\n    if (messageType.value === 'error') {\n      throw parseError(parsedMessage);\n    } else if (messageType.value !== 'event') {\n      // not sure how to parse non-events/non-errors, ignore for now\n      return;\n    }\n  } // determine event type\n\n\n  var eventType = parsedMessage.headers[':event-type']; // check that the event type is modeled\n\n  var eventModel = shape.members[eventType.value];\n\n  if (!eventModel) {\n    return;\n  }\n\n  var result = {}; // check if an event payload exists\n\n  var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n\n  if (eventPayloadMemberName) {\n    var payloadShape = eventModel.members[eventPayloadMemberName]; // if the shape is binary, return the byte array\n\n    if (payloadShape.type === 'binary') {\n      result[eventPayloadMemberName] = parsedMessage.body;\n    } else {\n      result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n    }\n  } // read event headers\n\n\n  var eventHeaderNames = eventModel.eventHeaderMemberNames;\n\n  for (var i = 0; i < eventHeaderNames.length; i++) {\n    var name = eventHeaderNames[i];\n\n    if (parsedMessage.headers[name]) {\n      // parse the header!\n      result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n    }\n  }\n\n  var output = {};\n  output[eventType.value] = result;\n  return output;\n}\n\nfunction parseError(message) {\n  var errorCode = message.headers[':error-code'];\n  var errorMessage = message.headers[':error-message'];\n  var error = new Error(errorMessage.value || errorMessage);\n  error.code = error.name = errorCode.value || errorCode;\n  return error;\n}\n/**\n * @api private\n */\n\n\nmodule.exports = {\n  parseEvent: parseEvent\n};","map":{"version":3,"names":["parseMessage","require","parseEvent","parser","message","shape","parsedMessage","messageType","headers","value","parseError","eventType","eventModel","members","result","eventPayloadMemberName","payloadShape","type","body","parse","toString","eventHeaderNames","eventHeaderMemberNames","i","length","name","toType","output","errorCode","errorMessage","error","Error","code","module","exports"],"sources":["/Users/lazarbogdan/test/medicacasa-frontend/medicacasa-frontend/node_modules/aws-sdk/lib/event-stream/parse-event.js"],"sourcesContent":["var parseMessage = require('./parse-message').parseMessage;\n\n/**\n *\n * @param {*} parser\n * @param {Buffer} message\n * @param {*} shape\n * @api private\n */\nfunction parseEvent(parser, message, shape) {\n    var parsedMessage = parseMessage(message);\n\n    // check if message is an event or error\n    var messageType = parsedMessage.headers[':message-type'];\n    if (messageType) {\n        if (messageType.value === 'error') {\n            throw parseError(parsedMessage);\n        } else if (messageType.value !== 'event') {\n            // not sure how to parse non-events/non-errors, ignore for now\n            return;\n        }\n    }\n\n    // determine event type\n    var eventType = parsedMessage.headers[':event-type'];\n    // check that the event type is modeled\n    var eventModel = shape.members[eventType.value];\n    if (!eventModel) {\n        return;\n    }\n\n    var result = {};\n    // check if an event payload exists\n    var eventPayloadMemberName = eventModel.eventPayloadMemberName;\n    if (eventPayloadMemberName) {\n        var payloadShape = eventModel.members[eventPayloadMemberName];\n        // if the shape is binary, return the byte array\n        if (payloadShape.type === 'binary') {\n            result[eventPayloadMemberName] = parsedMessage.body;\n        } else {\n            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);\n        }\n    }\n\n    // read event headers\n    var eventHeaderNames = eventModel.eventHeaderMemberNames;\n    for (var i = 0; i < eventHeaderNames.length; i++) {\n        var name = eventHeaderNames[i];\n        if (parsedMessage.headers[name]) {\n            // parse the header!\n            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);\n        }\n    }\n\n    var output = {};\n    output[eventType.value] = result;\n    return output;\n}\n\nfunction parseError(message) {\n    var errorCode = message.headers[':error-code'];\n    var errorMessage = message.headers[':error-message'];\n    var error = new Error(errorMessage.value || errorMessage);\n    error.code = error.name = errorCode.value || errorCode;\n    return error;\n}\n\n/**\n * @api private\n */\nmodule.exports = {\n    parseEvent: parseEvent\n};\n"],"mappings":"AAAA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,YAA9C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAoBC,MAApB,EAA4BC,OAA5B,EAAqCC,KAArC,EAA4C;EACxC,IAAIC,aAAa,GAAGN,YAAY,CAACI,OAAD,CAAhC,CADwC,CAGxC;;EACA,IAAIG,WAAW,GAAGD,aAAa,CAACE,OAAd,CAAsB,eAAtB,CAAlB;;EACA,IAAID,WAAJ,EAAiB;IACb,IAAIA,WAAW,CAACE,KAAZ,KAAsB,OAA1B,EAAmC;MAC/B,MAAMC,UAAU,CAACJ,aAAD,CAAhB;IACH,CAFD,MAEO,IAAIC,WAAW,CAACE,KAAZ,KAAsB,OAA1B,EAAmC;MACtC;MACA;IACH;EACJ,CAZuC,CAcxC;;;EACA,IAAIE,SAAS,GAAGL,aAAa,CAACE,OAAd,CAAsB,aAAtB,CAAhB,CAfwC,CAgBxC;;EACA,IAAII,UAAU,GAAGP,KAAK,CAACQ,OAAN,CAAcF,SAAS,CAACF,KAAxB,CAAjB;;EACA,IAAI,CAACG,UAAL,EAAiB;IACb;EACH;;EAED,IAAIE,MAAM,GAAG,EAAb,CAtBwC,CAuBxC;;EACA,IAAIC,sBAAsB,GAAGH,UAAU,CAACG,sBAAxC;;EACA,IAAIA,sBAAJ,EAA4B;IACxB,IAAIC,YAAY,GAAGJ,UAAU,CAACC,OAAX,CAAmBE,sBAAnB,CAAnB,CADwB,CAExB;;IACA,IAAIC,YAAY,CAACC,IAAb,KAAsB,QAA1B,EAAoC;MAChCH,MAAM,CAACC,sBAAD,CAAN,GAAiCT,aAAa,CAACY,IAA/C;IACH,CAFD,MAEO;MACHJ,MAAM,CAACC,sBAAD,CAAN,GAAiCZ,MAAM,CAACgB,KAAP,CAAab,aAAa,CAACY,IAAd,CAAmBE,QAAnB,EAAb,EAA4CJ,YAA5C,CAAjC;IACH;EACJ,CAjCuC,CAmCxC;;;EACA,IAAIK,gBAAgB,GAAGT,UAAU,CAACU,sBAAlC;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,gBAAgB,CAACG,MAArC,EAA6CD,CAAC,EAA9C,EAAkD;IAC9C,IAAIE,IAAI,GAAGJ,gBAAgB,CAACE,CAAD,CAA3B;;IACA,IAAIjB,aAAa,CAACE,OAAd,CAAsBiB,IAAtB,CAAJ,EAAiC;MAC7B;MACAX,MAAM,CAACW,IAAD,CAAN,GAAeb,UAAU,CAACC,OAAX,CAAmBY,IAAnB,EAAyBC,MAAzB,CAAgCpB,aAAa,CAACE,OAAd,CAAsBiB,IAAtB,EAA4BhB,KAA5D,CAAf;IACH;EACJ;;EAED,IAAIkB,MAAM,GAAG,EAAb;EACAA,MAAM,CAAChB,SAAS,CAACF,KAAX,CAAN,GAA0BK,MAA1B;EACA,OAAOa,MAAP;AACH;;AAED,SAASjB,UAAT,CAAoBN,OAApB,EAA6B;EACzB,IAAIwB,SAAS,GAAGxB,OAAO,CAACI,OAAR,CAAgB,aAAhB,CAAhB;EACA,IAAIqB,YAAY,GAAGzB,OAAO,CAACI,OAAR,CAAgB,gBAAhB,CAAnB;EACA,IAAIsB,KAAK,GAAG,IAAIC,KAAJ,CAAUF,YAAY,CAACpB,KAAb,IAAsBoB,YAAhC,CAAZ;EACAC,KAAK,CAACE,IAAN,GAAaF,KAAK,CAACL,IAAN,GAAaG,SAAS,CAACnB,KAAV,IAAmBmB,SAA7C;EACA,OAAOE,KAAP;AACH;AAED;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,GAAiB;EACbhC,UAAU,EAAEA;AADC,CAAjB"},"metadata":{},"sourceType":"script"}