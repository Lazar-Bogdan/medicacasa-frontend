{"ast":null,"code":"import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n/**\n * @public\n */\n\nvar AnimateSharedLayout =\n/** @class */\nfunction (_super) {\n  __extends(AnimateSharedLayout, _super);\n\n  function AnimateSharedLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * A list of all the children in the shared layout\n     */\n\n\n    _this.children = new Set();\n    /**\n     * As animate components with a defined `layoutId` are added/removed to the tree,\n     * we store them in order. When one is added, it will animate out from the\n     * previous one, and when it's removed, it'll animate to the previous one.\n     */\n\n    _this.stacks = new Map();\n    /**\n     * Track whether the component has mounted. If it hasn't, the presence of added children\n     * are set to Present, whereas if it has they're considered Entering\n     */\n\n    _this.hasMounted = false;\n    /**\n     * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n     * and schedule one.\n     */\n\n    _this.updateScheduled = false;\n    /**\n     * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n     */\n\n    _this.renderScheduled = false;\n    /**\n     * The methods provided to all children in the shared layout tree.\n     */\n\n    _this.syncContext = __assign(__assign({}, createBatcher()), {\n      syncUpdate: function (force) {\n        return _this.scheduleUpdate(force);\n      },\n      forceUpdate: function () {\n        // By copying syncContext to itself, when this component re-renders it'll also re-render\n        // all children subscribed to the SharedLayout context.\n        _this.syncContext = __assign({}, _this.syncContext);\n\n        _this.scheduleUpdate(true);\n      },\n      register: function (child) {\n        return _this.addChild(child);\n      },\n      remove: function (child) {\n        return _this.removeChild(child);\n      }\n    });\n    return _this;\n  }\n\n  AnimateSharedLayout.prototype.componentDidMount = function () {\n    this.hasMounted = true;\n  };\n\n  AnimateSharedLayout.prototype.componentDidUpdate = function () {\n    this.startLayoutAnimation();\n  };\n\n  AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n    this.renderScheduled = true;\n    return true;\n  };\n\n  AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n    var _this = this;\n    /**\n     * Reset update and render scheduled status\n     */\n\n\n    this.renderScheduled = this.updateScheduled = false;\n    var type = this.props.type;\n    /**\n     * Update presence metadata based on the latest AnimatePresence status.\n     * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n     */\n\n    this.children.forEach(function (child) {\n      if (!child.isPresent) {\n        child.presence = Presence.Exiting;\n      } else if (child.presence !== Presence.Entering) {\n        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;\n      }\n    });\n    this.updateStacks();\n    /**\n     * Create a handler which we can use to flush the children animations\n     */\n\n    var handler = {\n      layoutReady: function (child) {\n        if (child.getLayoutId() !== undefined) {\n          var stack = _this.getStack(child);\n\n          stack.animate(child, type === \"crossfade\");\n        } else {\n          child.notifyLayoutReady();\n        }\n      },\n      parent: this.context.visualElement\n    };\n    /**\n     * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n     * This requires some co-ordination across components to stop layout thrashing\n     * and ensure measurements are taken at the correct time.\n     *\n     * Here we use that same mechanism of schedule/flush.\n     */\n\n    this.children.forEach(function (child) {\n      return _this.syncContext.add(child);\n    });\n    this.syncContext.flush(handler);\n    /**\n     * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.clearSnapshot();\n    });\n  };\n\n  AnimateSharedLayout.prototype.updateStacks = function () {\n    this.stacks.forEach(function (stack) {\n      return stack.updateLeadAndFollow();\n    });\n  };\n\n  AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!(force || !this.updateScheduled)) return;\n    /**\n     * Flag we've scheduled an update\n     */\n\n    this.updateScheduled = true;\n    /**\n     * Write: Reset transforms so bounding boxes can be accurately measured.\n     */\n\n    this.children.forEach(function (child) {\n      resetRotate(child);\n      if (child.shouldResetTransform()) child.resetTransform();\n    });\n    /**\n     * Read: Snapshot children\n     */\n\n    this.children.forEach(snapshotViewportBox);\n    /**\n     * Every child keeps a local snapshot, but we also want to record\n     * snapshots of the visible children as, if they're are being removed\n     * in this render, we can still access them.\n     *\n     * TODO: What would be better here is doing a single loop where we\n     * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n     */\n\n    this.stacks.forEach(function (stack) {\n      return stack.updateSnapshot();\n    });\n    /**\n     * Force a rerender by setting state if we aren't already going to render.\n     */\n\n    if (force || !this.renderScheduled) {\n      this.renderScheduled = true;\n      this.forceUpdate();\n    }\n  };\n\n  AnimateSharedLayout.prototype.addChild = function (child) {\n    this.children.add(child);\n    this.addToStack(child);\n    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n  };\n\n  AnimateSharedLayout.prototype.removeChild = function (child) {\n    this.scheduleUpdate();\n    this.children.delete(child);\n    this.removeFromStack(child);\n  };\n\n  AnimateSharedLayout.prototype.addToStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.add(child);\n  };\n\n  AnimateSharedLayout.prototype.removeFromStack = function (child) {\n    var stack = this.getStack(child);\n    stack === null || stack === void 0 ? void 0 : stack.remove(child);\n  };\n  /**\n   * Return a stack of animate children based on the provided layoutId.\n   * Will create a stack if none currently exists with that layoutId.\n   */\n\n\n  AnimateSharedLayout.prototype.getStack = function (child) {\n    var id = child.getLayoutId();\n    if (id === undefined) return; // Create stack if it doesn't already exist\n\n    !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n    return this.stacks.get(id);\n  };\n\n  AnimateSharedLayout.prototype.render = function () {\n    return React.createElement(SharedLayoutContext.Provider, {\n      value: this.syncContext\n    }, this.props.children);\n  };\n\n  AnimateSharedLayout.contextType = MotionContext;\n  return AnimateSharedLayout;\n}(React.Component);\n\nexport { AnimateSharedLayout };","map":{"version":3,"names":["__extends","__assign","React","Presence","layoutStack","SharedLayoutContext","MotionContext","resetRotate","createBatcher","snapshotViewportBox","AnimateSharedLayout","_super","_this","apply","arguments","children","Set","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","syncUpdate","force","scheduleUpdate","forceUpdate","register","child","addChild","remove","removeChild","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","presence","Exiting","Entering","Present","updateStacks","handler","layoutReady","getLayoutId","undefined","stack","getStack","animate","notifyLayoutReady","parent","context","visualElement","add","flush","clearSnapshot","updateLeadAndFollow","shouldResetTransform","resetTransform","updateSnapshot","addToStack","delete","removeFromStack","id","has","set","get","render","createElement","Provider","value","contextType","Component"],"sources":["/Users/lazarbogdan/test/medicacasa-frontend/medicacasa-frontend/node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js"],"sourcesContent":["import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}